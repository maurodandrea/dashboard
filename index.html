<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>Governance Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f9f9f9;
      color: #333;
    }
    h2 {
      margin-bottom: 10px;
    }
    label {
      font-weight: bold;
      display: block;
      margin-bottom: 6px;
      margin-top: 20px;
    }
    select {
      padding: 8px 12px;
      font-size: 16px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: white;
      min-width: 220px;
      cursor: pointer;
      transition: border-color 0.3s ease;
    }
    select:hover, select:focus {
      border-color: #007bff;
      outline: none;
    }
    canvas {
      background: white;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.1);
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h2>Governance Dashboard</h2>

  <label for="dateSelect">Seleziona la data</label>
  <select id="dateSelect">
    <option value="">-- Seleziona una data --</option>
  </select>

  <canvas id="myChart" width="800" height="400"></canvas>

  <label for="productSelect">Seleziona il prodotto</label>
  <select id="productSelect">
    <option value="All">All</option>
  </select>

  <label>Issues totali per data (stacked)</label>
  <canvas id="aggregateByDateChart" width="800" height="400"></canvas>

  <script>
    let allData = [];
    let chartInstance = null;
    let chartAggregateByDate = null;

    const dateSelect = document.getElementById('dateSelect');
    const productSelect = document.getElementById('productSelect');

    // Carica ed elabora il file Excel
    fetch('Governance Dahsboard.xlsx')
      .then(response => {
        if (!response.ok) throw new Error('File non trovato o errore nel caricamento');
        return response.arrayBuffer();
      })
      .then(data => {
        const workbook = XLSX.read(data, { type: 'array' });
        const sheetName = 'Dati';
        const worksheet = workbook.Sheets[sheetName];

        if (!worksheet) {
          alert('Foglio "Dati" non trovato!');
          return;
        }

        allData = XLSX.utils.sheet_to_json(worksheet).map(row => {
          const formattedDate = row.data ? String(row.data).trim() : '';
          const toNumber = val => {
            const num = Number(val);
            return isNaN(num) ? 0 : num;
          };

          return {
            ...row,
            data: formattedDate,
            issue_high: toNumber(row.issue_high),
            issue_medium: toNumber(row.issue_medium),
            issue_low: toNumber(row.issue_low)
          };
        });

        // Prepara lista date uniche ordinate (stringhe gg/mm/aaaa)
        const uniqueDates = [...new Set(allData.map(row => row.data).filter(d => d))].sort();

        // Popola la combo date con date così come sono
        dateSelect.innerHTML = '<option value="">-- Seleziona una data --</option>';
        uniqueDates.forEach(dateStr => {
          const option = document.createElement('option');
          option.value = dateStr;
          option.textContent = dateStr;
          dateSelect.appendChild(option);
        });

        // Popola lista prodotti unici + "All" per filtro
        const uniqueProducts = [...new Set(allData.map(row => row.prodotto).filter(p => p && p.trim() !== ''))].sort();
        productSelect.innerHTML = '<option value="All">All</option>';
        uniqueProducts.forEach(prod => {
          const option = document.createElement('option');
          option.value = prod;
          option.textContent = prod;
          productSelect.appendChild(option);
        });

        // Seleziona di default la data più recente (ultima stringa ordinata)
        if (uniqueDates.length > 0) {
          const lastDate = uniqueDates[uniqueDates.length - 1];
          dateSelect.value = lastDate;
          renderChartForDate(lastDate);
        }

        renderAggregateByDateChart();
      })
      .catch(err => alert('Errore nel caricamento del file Excel: ' + err));

    dateSelect.addEventListener('change', () => {
      const selectedDate = dateSelect.value;
      if (selectedDate) {
        renderChartForDate(selectedDate);
      }
    });

    productSelect.addEventListener('change', () => {
      renderAggregateByDateChart();
    });

    function renderChartForDate(selectedDate) {
      const filtered = allData.filter(row =>
        row.data === selectedDate && row.prodotto && row.prodotto.trim() !== ''
      );

      const labels = filtered.map(row => row.prodotto);
      const highIssues = filtered.map(row => row.issue_high || 0);
      const mediumIssues = filtered.map(row => row.issue_medium || 0);
      const lowIssues = filtered.map(row => row.issue_low || 0);

      const ctx = document.getElementById('myChart').getContext('2d');

      if (chartInstance) chartInstance.destroy();

      chartInstance = new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [
            {
              label: 'High',
              data: highIssues,
              backgroundColor: 'rgba(255, 99, 132, 0.7)',
              stack: 'stack1',
            },
            {
              label: 'Medium',
              data: mediumIssues,
              backgroundColor: 'rgba(255, 206, 86, 0.7)',
              stack: 'stack1',
            },
            {
              label: 'Low',
              data: lowIssues,
              backgroundColor: 'rgba(75, 192, 192, 0.7)',
              stack: 'stack1',
            },
          ],
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: `Issues per Prodotto - Data: ${selectedDate}`,
            },
          },
          scales: {
            x: {
              stacked: true,
            },
            y: {
              stacked: true,
              beginAtZero: true,
            },
          },
        },
      });
    }

    function renderAggregateByDateChart() {
      const selectedProduct = productSelect.value;
      const aggregatedData = {};

      allData.forEach(row => {
        // Se filtro su prodotto diverso da All, includo solo righe di quel prodotto
        if (selectedProduct !== 'All' && row.prodotto !== selectedProduct) return;

        if (!row.prodotto || row.prodotto.trim() === '') return;

        const date = row.data;
        if (!date) return;

        if (!aggregatedData[date]) {
          aggregatedData[date] = {
            high: 0,
            medium: 0,
            low: 0
          };
        }

        aggregatedData[date].high += row.issue_high || 0;
        aggregatedData[date].medium += row.issue_medium || 0;
        aggregatedData[date].low += row.issue_low || 0;
      });

      const sortedDates = Object.keys(aggregatedData).sort();

      const highData = sortedDates.map(date => aggregatedData[date].high);
      const mediumData = sortedDates.map(date => aggregatedData[date].medium);
      const lowData = sortedDates.map(date => aggregatedData[date].low);

      const ctx = document.getElementById('aggregateByDateChart').getContext('2d');

      if (chartAggregateByDate) chartAggregateByDate.destroy();

      chartAggregateByDate = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sortedDates,
          datasets: [
            {
              label: 'High',
              data: highData,
              backgroundColor: 'rgba(255, 99, 132, 0.7)',
              stack: 'stack1',
            },
            {
              label: 'Medium',
              data: mediumData,
              backgroundColor: 'rgba(255, 206, 86, 0.7)',
              stack: 'stack1',
            },
            {
              label: 'Low',
              data: lowData,
              backgroundColor: 'rgba(75, 192, 192, 0.7)',
              stack: 'stack1',
            },
          ]
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: selectedProduct === 'All' ? 'Issues totali per data (stacked)' : `Issues totali per Data - Prodotto: ${selectedProduct}`,
            },
            legend: {
              position: 'top',
            }
          },
          scales: {
            x: {
              stacked: true,
              title: {
                display: true,
                text: 'Data'
              }
            },
            y: {
              stacked: true,
              beginAtZero: true,
              title: {
                display: true,
                text: 'Totale Issues'
              }
            }
          }
        }
      });
    }
  </script>
</body>
</html>